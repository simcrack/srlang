package ch.ffhs.srlang.skript.parser;

import java.util.ArrayList;
import java_cup.runtime.*;
import ch.ffhs.srlang.skript.instr.*;

terminal String literalBoolean;	// (false\|true)
terminal String literalInteger;	// [-+]{0,1}[0-9]+
terminal String literalString;	// "[^"]{0,256}"

terminal kwAdd;	// \+
terminal kwAssign;	// :=
terminal kwCompare;	// ==
terminal kwCurlyClose;	// \}
terminal kwCurlyOpen;	// \{
terminal kwDiv;	// \/
terminal kwList;	// ,
terminal kwMul;	// \*
terminal kwRoundClose;	// \)
terminal kwRoundOpen;	// \(
terminal kwSub;	// -

terminal kwEnd;	// ;
terminal kwElse;	// el
terminal kwFunction;	// fn
terminal kwIf;	// if
terminal kwLoop;	// lp
terminal kwReturn;	// ret
terminal comment;	// \/\/[\n]*
terminal String identifier;	// [a-zA-z][a-zA-Z0-9]{0,255}

non terminal Instruction SCRIPT;
non terminal ArrayList<Instruction> ASSIGNMENT_LIST;
non terminal Instruction ASSIGNMENT;
non terminal Instruction SUM, PRODUCT, SIMPLE_TERM;
non terminal ENDE;

start with SCRIPT;

SCRIPT ::= ASSIGNMENT_LIST:al SUM:s ENDE
                        {: RESULT = new InstructionScript(al, s); :}
                     ;

ASSIGNMENT_LIST ::=
                  {:  RESULT = new ArrayList<Instruction>(); :}
               |  ASSIGNMENT_LIST:al ASSIGNMENT:a
                  {:  RESULT = al;
                      RESULT.add(a);
                  :}
               ;

ENDE ::=
    |  kwEnd
    ;

ASSIGNMENT ::= identifier:n kwAssign SUM:s kwEnd
               {: RESULT = new InstructionSetVariable(n, s); :}
             ;


SUM ::= PRODUCT:p
       {: RESULT = p; :}
    |  kwSub PRODUCT:p
       {: RESULT = new InstructionNegate(p); :}
    |  SUM:s kwAdd PRODUCT:p
       {: RESULT = new InstructionBinaryOperation(BinaryOperator.PLUS, s, p); :}
    |  SUM:s kwSub PRODUCT:p
       {: RESULT = new InstructionBinaryOperation(BinaryOperator.MINUS, s, p); :}
    ;

PRODUCT ::= SIMPLE_TERM:st
           {: RESULT = st; :}
        |  PRODUCT:p kwMul SIMPLE_TERM:st
           {: RESULT = new InstructionBinaryOperation(BinaryOperator.TIMES, p, st); :}
        |  PRODUCT:p kwDiv SIMPLE_TERM:st
           {: RESULT = new InstructionBinaryOperation(BinaryOperator.DIV, p, st); :}
        ;

SIMPLE_TERM ::= identifier:n
               {: RESULT = new InstructionGetVariable(n); :}
            |  literalInteger:n
               {: RESULT = InstructionConstant.integer(n); :}
            |  kwRoundOpen SUM:s kwRoundClose
               {: RESULT = s; :}
            ;
